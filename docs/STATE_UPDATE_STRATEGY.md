## 상태 업데이트 전략과 setState 활용성

### 1. setState가 전체 렌더링을 유발하는 이유
- `Component.setState()` 는 내부 state를 불변 업데이트한 뒤 `shouldUpdate → update → render` 순으로 전체 템플릿을 다시 생성합니다.
- 현재 프레임워크에는 Virtual DOM이 없어서, `render()`가 반환한 문자열을 DOM으로 변환하고 `_patchDom`으로 diff 합니다.
- DOM diff가 element 단위로만 동작하기 때문에, 큰 레이아웃을 가진 페이지에서는 스크롤 영역 전체가 다시 그려져 “깜빡임”이 생길 수 있습니다.

### 2. BlogListPage 개선 사례
- BlogListPage처럼 목록과 사이드바가 큰 레이아웃을 구성하는 페이지에서 `setState`를 통해 데이터를 갱신하면 전체 페이지가 다시 렌더링되어 눈에 띄는 깜빡임이 발생했습니다.
- 해결 방법으로 **리스트 데이터는 state에 직접 할당**하고, 리스트 영역과 페이지네이션 영역을 각각 담당하는 헬퍼(`renderPosts`, `renderPaginationPages`)만 호출해 부분 업데이트 하도록 변경했습니다.
- 이 방식은 Virtual DOM 없이도 특정 영역만 다시 그릴 수 있어서 성능과 사용자 경험을 모두 개선합니다.

### 3. setState가 여전히 의미 있는 이유
- `setState` 자체는 “상태 변경 + 재렌더 트리거”라는 일관된 흐름을 제공합니다. 단순한 컴포넌트나 작은 UI 조각에서는 여전히 가장 간단하고 명시적인 방법입니다.
- 상태 스냅샷(`prevState`)과 라이프사이클(`shouldUpdate`, `updated`)을 자동으로 연결해 주기 때문에, 개별 DOM 조작을 직접 관리할 필요가 없습니다.
- 따라서 **대부분의 컴포넌트에서는 setState를 그대로 사용**하고, 렌더 비용이 큰 일부 페이지만 부분 렌더링 전략을 적용하는 것이 현실적인 절충안입니다.

### 4. Virtual DOM 도입 고려 사항
- Virtual DOM을 완전히 도입하려면 모든 컴포넌트의 `render()` 결과를 VNode 트리로 바꾸고 diff 알고리즘을 재구현해야 하므로 공수가 큽니다.
- 현재 프레임워크 전체를 다시 구성할 계획이 없다면, 필요한 페이지에서만 부분 렌더링을 적용하는 방식이 훨씬 적은 비용으로 동일한 UX 문제를 해결할 수 있습니다.
