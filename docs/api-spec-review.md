# API 스펙 평가 및 개선 제안

대상 문서: `docs/api-spec.md`  
근거 코드: `src/api/*`, `src/types/*`, `src/features/auth/*` 등

이 문서는 기존 API 스펙을 **비판적 관점에서 리뷰**하고, 잘못되었거나 위험할 수 있는 부분과 개선 아이디어를 정리한 것이다.  
실제 서버 구현은 보지 못했으므로, 일부 내용은 “추정 기반”이라는 점을 전제로 한다.

---

## 1. 보안 측면 이슈

### 1-1. `accessToken`을 `localStorage`에 저장

- **문제**
  - `httpClient`가 `localStorage.getItem('accessToken')`를 통해 토큰을 읽어 `Authorization` 헤더에 넣는다.
  - 로컬 스토리지는 JavaScript로 언제든 접근 가능하기 때문에, XSS 공격에 노출되면 토큰 탈취 위험이 매우 크다.
- **영향**
  - XSS 한 번으로 장기 세션 탈취 가능.
  - 특히 refresh 토큰이 쿠키에 있고 accessToken 만으로도 중요한 API 대부분을 호출할 수 있다면, 실질적인 계정 탈취로 이어질 수 있다.
- **개선 제안**
  - 가능하면 accessToken도 `httpOnly`, `secure`, `sameSite` 쿠키 기반으로 전환하거나, 최소한 로컬 스토리지 대신 메모리 기반 + 짧은 만료시간 등으로 리스크를 줄인다.
  - CSP(Content Security Policy), 정적 분석, XSS 방어(escape, sanitizer 등)를 반드시 함께 강화한다.

### 1-2. Refresh 토큰 기반 API의 CSRF 노출 가능성

- **상황**
  - `POST {API_BASE_URL}/auth/refresh`는 `withCredentials: true`로 호출되며, HttpOnly 쿠키에 있는 리프레시 토큰을 사용한다고 추정된다.
  - 이 엔드포인트는 액세스 토큰 없이도(쿠키만 있으면) 호출이 가능해야 하므로, **CSRF 공격에 매우 취약한 지점**이 될 수 있다.
- **문제**
  - CSRF 방어 장치(예: CSRF 토큰, SameSite=strict/lax 설정, Origin/Referer 검증 등)가 없다면, 악성 사이트에서 사용자의 브라우저를 이용해 `/auth/refresh`를 호출해 accessToken을 발급받고, 그 토큰을 응답 바디를 통해 탈취할 수 있다.
- **개선 제안**
  - `/auth/refresh` 요청에 대해 반드시 **CSRF 토큰 검증** 또는 **엄격한 SameSite 정책**을 적용한다.
  - 가능하면 refresh 응답 시에도 토큰을 바디로 내려주지 말고, 쿠키에만 설정하도록 설계하면 탈취 위험을 크게 줄일 수 있다.

### 1-3. 로그인/회원가입 시 토큰 반환 방식

- **상황**
  - `POST /auth/login`, `POST /auth/signup`은 응답 바디에 `accessToken`을 포함해서 내려준다.
- **문제**
  - 액세스 토큰을 바디로 내려주면, 브라우저 이외 환경(프록시, 로깅 시스템 등)에서 노출될 가능성이 늘어난다.
  - XSS 취약점과 결합하면 토큰 탈취 난이도가 낮아진다.
- **개선 제안**
  - 가능하면 login/signup 성공 시에도 토큰을 전적으로 HttpOnly 쿠키로만 주고, 응답 바디에는 민감 정보(토큰)를 포함하지 않도록 설계하는 편이 안전하다.

### 1-4. 인증/인가 정책이 API 스펙에 드러나지 않음

- **상황**
  - 각 엔드포인트가 “로그인 필요/불필요”, “작성자 전용/관리자 전용”인지에 대한 명시가 없다.
- **문제**
  - 프론트/백엔드 간에 권한 관련 오해가 생기기 쉽고, 잘못된 클라이언트 구현으로 인해 취약점이 발생할 수 있다.
- **개선 제안**
  - 각 API에 대해 최소한 다음 정도를 문서에 명시하는 것이 좋다.
    - 인증 필요 여부(Authorization 헤더 필수인지)
    - 필요 권한(예: `role: admin`, “자기 자신만 접근 가능” 등)

---

## 2. DTO/모델 설계 상의 문제점

### 2-1. `MemberResponse`의 `memberId` vs `id` 중복

- **상황**
  - `MemberResponse`에 `memberId: number`와 `id: number`가 동시에 존재하며, 목 데이터에서는 두 값이 동일하게 세팅된다.
  - 실제 사용 코드도 `user.memberId`와 `user.id`를 혼용할 여지가 있다.
- **문제**
  - 하나의 엔터티에 식별자 필드가 두 개 존재하면, 어느 필드가 진짜 PK인지, 언제 어떤 필드를 써야 하는지 혼란을 야기한다.
  - API 진화 과정에서 둘이 다른 의미를 갖게 되면, 프론트/백 모두 유지보수 난이도가 급격히 상승한다.
- **개선 제안**
  - 외부 노출 ID를 하나로 통일(`memberId` 또는 `id`)하고, 나머지는 제거한다.
  - 만약 내부/외부 ID가 다르다면, 외부에는 하나만 명시하고 내부 ID는 노출하지 않는 편이 바람직하다.

### 2-2. `Partial<MemberResponse>`를 이용한 프로필 수정

- **상황**
  - `PUT /api/v1/members/me`의 요청 바디 타입을 프론트에서 `Partial<MemberResponse>`로 사용하고 있다.
- **문제**
  - 응답 모델과 수정용 요청 모델을 같은 타입으로 사용하면:
    - 원래 클라이언트가 변경해서는 안 되는 필드(`id`, `memberId`, `email`, `role` 등)까지 수정 요청에 포함될 수 있다.
    - 서버가 유효성 검사를 잘못 구현하면, 권한을 넘어선 수정이 가능해지는 취약점으로 이어질 수 있다.
- **개선 제안**
  - 수정용 요청 DTO를 별도로 정의하는 것이 좋다. 예:
    - `UpdateProfileRequest`:
      - `nickname`, `bio`, `profileImage`, `primaryStack`, `interests`, `socialLinks` 등 **사용자가 실제로 수정 가능한 필드만** 포함.
  - 응답 DTO(`MemberResponse`)와 요청 DTO를 명확히 분리하면, 권한/검증 로직도 더 명확해진다.

### 2-3. `PostCreateRequest` / `PostUpdateRequest` 타입 구조

- **상황**
  - `PostCreateRequest`와 `PostUpdateRequest`가 별도로 정의되어 있지만, 실제 API 호출에서는 둘 다 `PostCreateRequest` 모양의 데이터를 사용한다.
- **문제**
  - 타입 정의와 실제 사용이 불일치한다는 것은, 설계 의도가 코드에 반영되지 못하고 있다는 신호다.
  - 추후 부분 업데이트(필수/선택 필드 차이 등)를 도입할 때 혼란을 유발할 수 있다.
- **개선 제안**
  - 실제 요구사항에 맞게 타입을 정리한다.
    - 생성용: `PostCreateRequest` (필수 필드 강조).
    - 수정용: `PostUpdateRequest` (부분 수정 허용 시 대부분 optional).
  - 프론트 코드에서 `updatePost` 호출 시에도 `PostUpdateRequest` 타입을 사용하도록 맞추면 좋다.

### 2-4. 응답 래퍼 `ApiResponse<T>`의 일관성/확장성

- **상황**
  - 모든 API가 `ApiResponse<T>`로 래핑되어 있으며, `message`, `errors`를 가지고 있다.
- **문제 (디자인 관점)**
  - HTTP status code와의 연계가 문서상 전혀 드러나지 않는다.
    - 실제로 항상 200에 `success=false`만 바뀌는지, 아니면 에러 시 4xx/5xx를 함께 쓰는지 불명확하다.
  - 클라이언트 입장에서, `errors`가 언제 어떤 형식으로 채워지는지 기준이 없으면 에러 처리 로직을 표준화하기 어렵다.
- **개선 제안**
  - 문서에 다음을 명시하는 것이 바람직하다.
    - 성공/실패 시 대표적인 HTTP status code.
    - `message`와 `errors` 필드가 사용되는 패턴(예: 유효성 에러는 400 + `errors` 배열, 서버 에러는 500 + `message`만 등).

---

## 3. REST/일관성 측면 이슈

### 3-1. 버전 경로(`/api/v1`) 사용의 일관성 부족

- **상황**
  - `member`, `post`, `comment` 관련 API는 `/api/v1/...` 경로를 사용한다.
  - 반면 `auth` 관련 API는 `/auth/...` (버전 경로 없음)을 사용한다.
- **문제**
  - URL 공간 설계 기준이 혼재되어 있어, 장기적인 API 버전 관리/마이크로서비스 분리에 불리하다.
  - 클라이언트 개발자 입장에서도 “어떤 도메인은 `/api/v1`, 어떤 도메인은 `/auth`”와 같이 규칙이 단순하지 않음.
- **개선 제안**
  - 가능하면 인증 관련 API도 버전 경로 아래에 두는 것이 좋다. 예:
    - `/api/v1/auth/login`, `/api/v1/auth/signup`, `/api/v1/auth/refresh` 등.
  - 이미 배포된 서비스라면, 새로운 버전(`/api/v2/...`)의 설계 시 일관성 있게 정리하는 전략을 권장.

### 3-2. 좋아요 토글 API의 HTTP 메서드 의미

- **상황**
  - `POST /api/v1/posts/{postId}/like`가 좋아요 토글(혹은 좋아요/취소 모두)을 담당하는 것으로 보인다.
- **문제**
  - 토글 로직이 `POST` 하나로 묶여 있으면, 클라이언트/서버 양쪽에서 동기화 버그가 발생하기 쉽다.
  - REST 관점에서는 “리소스 생성/삭제”에 더 가까운 의미이므로, `PUT`(좋아요 설정) / `DELETE`(좋아요 해제)처럼 명시적인 방식이 더 직관적이다.
- **개선 제안**
  - 설계를 다음 중 하나로 정리하는 것이 좋다.
    - `PUT /posts/{id}/like` → 좋아요 설정, `DELETE /posts/{id}/like` → 좋아요 해제.
    - 혹은 `POST /posts/{id}/like`는 “항상 좋아요”만 수행하고, 취소는 별도 엔드포인트(`DELETE`)로 분리.

### 3-3. Auth 엔드포인트와 기타 엔드포인트의 도메인 분리

- **상황**
  - 현재는 `API_BASE_URL` 아래 `/auth/...`와 `/api/v1/...`가 혼재.
- **문제**
  - 인증 서버와 리소스 서버를 분리하거나 도메인 별로 나눌 때, URL 구조를 크게 바꿔야 할 수 있다.
- **개선 제안**
  - 장기적으로는 인증 도메인(`/auth`)과 리소스 도메인(`/api/v1`)을 역할에 따라 분리하되, 버저닝 전략을 함께 가져가는 것이 좋다.

---

## 4. 문서/스펙 표현 상의 아쉬운 점

### 4-1. 권한/에러/성공 케이스에 대한 서술 부족

- **문제**
  - 각 API가 어떤 상황에서 어떤 상태 코드와 어떤 응답 바디를 반환하는지 상세 서술이 없다.
  - 예: 로그인 실패(잘못된 비밀번호), 리프레시 토큰 만료, 권한 없는 사용자(403) 등.
- **개선 제안**
  - 각 엔드포인트마다 최소한 다음 정보를 추가하면 문서로서 훨씬 유용해진다.
    - 정상(200/201 등) 응답 예시.
    - 대표적인 에러 케이스(400/401/403/404/409/500 등)와 그 때의 `message`, `errors` 구조.
    - 인증/인가 실패 시의 동작 정의.

### 4-2. 필드 레벨 제약조건(Validation Rule) 누락

- **문제**
  - `email`, `password`, `nickname`, `title`, `content` 등 필수 필드들에 대한 길이, 포맷, 허용 문자 등에 대한 설명이 없다.
- **영향**
  - 프론트에서 어떤 기준으로 사전 검증을 해야 하는지 알 수 없다.
  - 서버와 클라이언트의 검증 기준이 쉽게 어긋날 수 있다.
- **개선 제안**
  - DTO 정의에 필드별 제약조건을 추가 문서화한다.
    - 예: `password`: 8~64자, 영문/숫자/특수문자 포함 등.
    - `title`: 최대 100자, 공백만 불가 등.

### 4-3. 가독성을 위한 엔드포인트 그룹 및 목차

- **상황**
  - 현재 `auth`, `member`, `post`, `comment` 단위로 잘 나뉘어 있지만, 상단에 전체 목차/요약이 없다.
- **개선 제안**
  - `docs/api-spec.md` 상단에 각 도메인별 엔드포인트 목록을 한 번에 볼 수 있는 목차를 추가하면, 새로운 팀원이 API를 파악하는 데 도움이 된다.

---

## 5. 정리

- 현재 스펙은 **프론트 입장에서 사용하기에는 꽤 일관적이고 직관적인 편**이다.
- 다만, 보안(특히 토큰 저장 위치/CSRF/리프레시 설계), DTO 분리, URL 버저닝/일관성, 에러 모델링 등의 부분은 실제 서비스 운영 관점에서 개선 여지가 크다.
- 위에 정리한 항목들은 우선순위를 정해 단계적으로 개선해 나가면 좋으며,
  - 1순위: 토큰/보안 관련 설계 재검토,
  - 2순위: DTO 분리 및 권한/에러 정책 문서화,
  - 3순위: URL 구조/버전 전략 정리
  정도를 추천한다.

